<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Solving Project Euler with Rust 2 - Unlogic</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="http://unlogic.co.uk/2015/01/20/solving-project-euler-with-rust-2/">

  
  

  
  

  
  

  <link rel="stylesheet" type="text/css" href="http://unlogic.co.uk//css/combined-min.css">

</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://unlogic.co.uk/" class="site-title">Unlogic</a>
      <nav class="site-nav right">
      <a href="http://unlogic.co.uk/tags">Tags</a>

</form>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1 class="py2">Solving Project Euler with Rust 2</h1>
        <span class="post-meta">Jan 20, 2015 by </span><br>
        
      </div>

      <article class="post-content">
      <p>Carrying on with <a href="http://unlogic.co.uk/2015/01/12/solving-project-euler-with-rust-1/">the series</a>, here&rsquo;s
how I solved Project Euler&rsquo;s problem 2:</p>

<pre><code>Even Fibonacci numbers
Problem 2
Each new term in the Fibonacci sequence is generated by adding the previous 
two terms. By starting with 1 and 2, the first 10 terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not 
exceed four million, find the sum of the even-valued terms.
</code></pre>

<p>Fairly similar to the previous one, in terms that we need to sum a sequence
of filtered numbers. This time though the sequence is not a straight run,
but the fibonacci sequence.</p>

<p>As usual with these issues I assume we will need a recursive function to generate
our fibonacci numbers:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w">    </span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>As I am still learning Rust, I am not sure if there&rsquo;s more Rustacean way of doing it.
I couldn&rsquo;t find anything relevant to this in the docs, so for now I will leave it
as it is until I get some feedback on it. I wonder if a closure would be better?</p>

<p>EDIT: From the comments below (thanks pf), this is a much more Rust like implementation IMO:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w">    </span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>


<p>Now I need to get a list of numbers while the return of the <code>fib</code> function
is &lt; 4,000,000. I cheated a bit here, as I figured out that the max number
to pass to the function in this case is 34.
I would assume that in the <em>more correct</em> way of doing it, the limit is
defined in a better way.</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">34</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</p>

<p>Thinking back to the previous example I already know about filter and sum.</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">34</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">sum</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</p>

<p>But there&rsquo;s a problem:</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">   Compiling euler_2 v0.0.1 (file:////work/sandbox/euler_rust/euler_2)</span>
<span class="go">/work/sandbox/euler_rust/euler_2/src/main.rs:16:10: 16:15 error: type `core::iter::Filter&lt;i32, core::iter::Map&lt;i32, i32, core::ops::Range&lt;i32&gt;, closure[/work/sandbox/euler_rust/euler_2/src/main.rs:14:32: 14:42]&gt;, closure[/work/sandbox/euler_rust/euler_2/src/main.rs:15:17: 15:31]&gt;` does not implement any method in scope named `sum`</span>
<span class="go">/work/sandbox/euler_rust/euler_2/src/main.rs:16         .sum();</span>
<span class="go">                                                        ^~~~~</span>
<span class="go">error: aborting due to previous error</span>
<span class="go">Could not compile `euler_2`.</span>
</code></pre></div>
</p>

<p>Seems like <code>sum</code> won&rsquo;t work here due to the <code>map</code>. Not to worry, I used <code>fold</code> in the previous example,
before the helpful folks at <a href="http://reddit.com/r/rust">/r/rust</a> told me about <code>sum</code>,
so let&rsquo;s use that instead, as that should work.</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">vals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.</span><span class="p">.</span><span class="mi">34</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">|</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span>
<span class="w">   </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">vals</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</p>

<p>EDIT: <code>sum</code> does work, I just forgot to add <code>use std::iter::AdditiveIterator;</code> at the
top of the file. The Github file contains this fix.</p>

<p>Let&rsquo;s run it:</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="go">cargo run</span>
<span class="go">     Running `target/euler_2`</span>
<span class="go">4613732</span>
</code></pre></div>
</p>

<p>The result checks out, so Project Euler 2 has been solved.</p>

<p>What I would like to know though: Is there a better way to generate the
fibonacci sequence? If you have suggestions (or about anything else on this page),
please leave me a message below. After all, this is a learning exercise for me
and for anyone else interested.</p>

<p>EDIT: With some marvellous feedback (which is a great benefit of posting
these) I have edited the code on Github to use an iterator instead of the recursive call.</p>

<p>The code is now (main credit to /u/emk and others):</p>

<p><div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">iter</span><span class="o">::</span><span class="n">AdditiveIterator</span><span class="p">;</span><span class="w"></span>

<span class="cp">#[derive(Copy)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">FibonacciSequence</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">n_minus_1</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">n_minus_2</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Iterator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FibonacciSequence</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">n_minus_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">n_minus_2</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Special case: If all our fields are zero, we want to generate</span>
<span class="w">        </span><span class="c1">// our initial 1.  Everything else will work correctly from here.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">n_minus_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">n_minus_1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">n_minus_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">fibonacci_sequence</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">FibonacciSequence</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">FibonacciSequence</span><span class="p">{</span><span class="n">n_minus_1</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n_minus_2</span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibonacci_sequence</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">take_while</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">v</span><span class="o">|</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">4000000</span><span class="k">u32</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">sum</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Result: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</p>

<p>The interesting thing is the performance difference between the iterator
implementation and the recursive call. The recursive implementation timings
are:</p>

<pre><code>real    0m0.311s
user    0m0.255s
sys 0m0.035s
</code></pre>

<p>Versus the timings of the iterator:</p>

<pre><code>real    0m0.079s
user    0m0.025s
sys 0m0.035s
</code></pre>

<p>Clearly a vast improvement there at the cost of a little extra code.
With the iterator the benefit stems from the fact that we track where we
are in the sequence. So for each number we don&rsquo;t need to recursively
call the <code>fib</code> function until n is 1, which is where the big saving comes from.</p>

<p>This and all future solutions are on <a href="https://github.com/Svenito/euler_rust">my Github</a></p>

<p>Also posted to <a href="https://www.reddit.com/r/rust/comments/2t23ow/still_learning_rust_following_on_with_a_write_up/">/r/rust</a></p>

      </article>

      <p class="post-meta">Tags:&nbsp;
        
            
            <a href="http://unlogic.co.uk//tags/rust">rust</a>
        
            ,&nbsp;
            <a href="http://unlogic.co.uk//tags/project%20euler">project euler</a>
        
            ,&nbsp;
            <a href="http://unlogic.co.uk//tags/programming">programming</a>
        
            ,&nbsp;
            <a href="http://unlogic.co.uk//tags/learning">learning</a>
        
      </p>

      
<div id="disqus_thread">
  <script type="text/javascript">
     var disqus_shortname = "unlogic";
     var disqus_identifier = "\/2015\/01\/20\/solving-project-euler-with-rust-2\/";

     (function() {
       var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
       dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
       (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
  </script>
</div>


    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="http://unlogic.co.uk/index.xml"></a>

<a class="fa fa-twitter twitter" href="https://twitter.com/binaryheadache"></a>

</nav>

          <small>
            Copyright &#169; 2015<br>
            Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
          </small>
        </div>
      </div>
    </footer>

    
    <script src="http://unlogic.co.uk/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    


</body>
</html>

