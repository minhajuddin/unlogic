---
comments: true
date: 2015-01-20T00:00:00Z
image:
  credit: null
  creditlink: null
  feature: null
modified: 2015-01-20 21:10:09 +0000
share: null
tags:
- rust
- project euler
- programming
- learning
title: Solving Project Euler with Rust 2
url: /2015/01/20/solving-project-euler-with-rust-2/
---

Carrying on with [the series](http://unlogic.co.uk/2015/01/12/solving-project-euler-with-rust-1/), here's 
how I solved Project Euler's problem 2:

    Even Fibonacci numbers
    Problem 2
    Each new term in the Fibonacci sequence is generated by adding the previous 
    two terms. By starting with 1 and 2, the first 10 terms will be:

        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values do not 
    exceed four million, find the sum of the even-valued terms.

Fairly similar to the previous one, in terms that we need to sum a sequence
of filtered numbers. This time though the sequence is not a straight run,
but the fibonacci sequence.

As usual with these issues I assume we will need a recursive function to generate
our fibonacci numbers:

{{< highlight rust >}}
fn fib(n: i32) -> i32{
    if n == 0 { 
        return 0;
    } else if n == 1 {
        return 1;
    } else {
        return fib(n-1) + fib(n-2);
    }    
}
{{< / highlight >}}

As I am still learning Rust, I am not sure if there's more Rustacean way of doing it.
I couldn't find anything relevant to this in the docs, so for now I will leave it 
as it is until I get some feedback on it. I wonder if a closure would be better?

EDIT: From the comments below (thanks pf), this is a much more Rust like implementation IMO:

{{< highlight rust >}}
fn fib(n: i32) -> i32{
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n-1) + fib(n-2),
    }    
}
{{< / highlight >}}

Now I need to get a list of numbers while the return of the `fib` function 
is < 4,000,000. I cheated a bit here, as I figured out that the max number 
to pass to the function in this case is 34.
I would assume that in the *more correct* way of doing it, the limit is
defined in a better way.

{{< highlight rust >}}
fn main() {
    let vals = (1..34).map(|x| fib(x));
}
{{< / highlight >}}

Thinking back to the previous example I already know about filter and sum.

{{< highlight rust >}}
fn main() {
    let vals = (1..34).map(|x| fib(x))
                .filter(|&x| x % 2 == 0)
                .sum();
}
{{< / highlight >}}

But there's a problem:

{{< highlight console >}}
   Compiling euler_2 v0.0.1 (file:////work/sandbox/euler_rust/euler_2)
/work/sandbox/euler_rust/euler_2/src/main.rs:16:10: 16:15 error: type `core::iter::Filter<i32, core::iter::Map<i32, i32, core::ops::Range<i32>, closure[/work/sandbox/euler_rust/euler_2/src/main.rs:14:32: 14:42]>, closure[/work/sandbox/euler_rust/euler_2/src/main.rs:15:17: 15:31]>` does not implement any method in scope named `sum`
/work/sandbox/euler_rust/euler_2/src/main.rs:16         .sum();
                                                        ^~~~~
error: aborting due to previous error
Could not compile `euler_2`.

{{< / highlight >}}

Seems like `sum` won't work here due to the `map`. Not to worry, I used `fold` in the previous example,
before the helpful folks at [/r/rust](http://reddit.com/r/rust) told me about `sum`,
so let's use that instead, as that should work.

{{< highlight rust >}}
fn main() {
    let vals = (1..34).map(|x| fib(x))
                .filter(|&x| x % 2 == 0)
                .fold(0, |a, b| a + b);
    
   println!("{}", vals);
}
{{< / highlight >}}

EDIT: `sum` does work, I just forgot to add `use std::iter::AdditiveIterator;` at the 
top of the file. The Github file contains this fix.

Let's run it:

{{< highlight console >}}
cargo run
     Running `target/euler_2`
4613732
{{< / highlight >}}

The result checks out, so Project Euler 2 has been solved.

What I would like to know though: Is there a better way to generate the 
fibonacci sequence? If you have suggestions (or about anything else on this page), 
please leave me a message below. After all, this is a learning exercise for me
and for anyone else interested.

EDIT: With some marvellous feedback (which is a great benefit of posting
these) I have edited the code on Github to use an iterator instead of the recursive call.

The code is now (main credit to /u/emk and others):

{{< highlight rust >}}
use std::iter::AdditiveIterator;

#[derive(Copy)]
pub struct FibonacciSequence {
    n_minus_1: u32,
    n_minus_2: u32
}

impl Iterator for FibonacciSequence {
    type Item = u32;
    fn next(&mut self) -> Option<u32> {
        let mut result = self.n_minus_1 + self.n_minus_2;

        // Special case: If all our fields are zero, we want to generate
        // our initial 1.  Everything else will work correctly from here.
        if result == 0 { result = 1; }

        self.n_minus_2 = self.n_minus_1;
        self.n_minus_1 = result;
        Some(result)
    }
}

pub fn fibonacci_sequence() -> FibonacciSequence {
    FibonacciSequence{n_minus_1: 0, n_minus_2: 0}
}

fn main() {
    let sum = fibonacci_sequence()
        .filter(|&v| v % 2 == 0)
        .take_while(|&v| v <= 4000000u32)
        .sum();

    println!("Result: {}", sum);
}
{{< / highlight >}}

The interesting thing is the performance difference between the iterator
implementation and the recursive call. The recursive implementation timings
are:

    real	0m0.311s
    user	0m0.255s
    sys	0m0.035s

Versus the timings of the iterator:

    real	0m0.079s
    user	0m0.025s
    sys	0m0.035s

Clearly a vast improvement there at the cost of a little extra code. 
With the iterator the benefit stems from the fact that we track where we
are in the sequence. So for each number we don't need to recursively
call the `fib` function until n is 1, which is where the big saving comes from.

This and all future solutions are on [my Github](https://github.com/Svenito/euler_rust)

Also posted to [/r/rust](https://www.reddit.com/r/rust/comments/2t23ow/still_learning_rust_following_on_with_a_write_up/)
